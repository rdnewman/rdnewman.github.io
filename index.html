<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Notes by rdnewman</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Notes by RDNewman</h1>
        <p class="header"></p>



        <ul>
          <li><a class="buttons github" href="https://github.com/rdnewman">GitHub Profile</a></li>
        </ul>

      </header>
      <section>
        <h2>
<a id="how-to-use-reactjs-to-handle-flash-messages-in-a-ruby-on-rails-40-project" class="anchor" href="#how-to-use-reactjs-to-handle-flash-messages-in-a-ruby-on-rails-40-project" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to use ReactJS to handle flash messages in a Ruby on Rails 4.0 project</h2>

<p>WARNING: code display is missing some <code>div</code>s.  Use view-source until I get the display fixed (so much for quick and dirty display).</p>



<h3>
<a id="basics" class="anchor" href="#basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basics</h3>

<p>Normally, Ruby flash messages are rendered server-side with perhaps a basic snippet of code in a layout view.  Something like this HAML could be used in basic Rails 4.0 layout (using Bootstrap):</p>

<p><em>(app/views/layouts/application.html.haml)</em>
<pre><code>!!!
%html
  %head
    %title
      Demo

    = stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' =&gt; true
    = javascript_include_tag 'application', 'data-turbolinks-track' =&gt; true
    = csrf_meta_tags

  %body
    %div.container
      %div#flash_messages
        - flash.each do |level, message|
          %div{class: "#{flash_class(level)}"}&lt;
            = message

      = yield
</code></pre>
</p>

<p>The reference to <code>flash_class</code> is just a helper for applying bootstrap styles.</p>

<p><em>(app/helpers/application_helper.rb)</em>
<pre><code>module ApplicationHelper
  # flash message typing for Bootstrap display
  def flash_class(level)
    case level
    when 'notice'
      'alert alert-info'
    when 'success'
      'alert alert-success'
    when 'error', 'alert'
      'alert alert-error'
    else
      'alert alert-error'
    end
  end
end
</code></pre>
</p>

<p>And this all works as fine as it goes.  Flash messages will be displayed on every page render.</p>

<h3>
<a id="react-and-ajax" class="anchor" href="#react-and-ajax" aria-hidden="true"><span class="octicon octicon-link"></span></a>React and AJAX</h3>

<p>However, if you're writing a <a href="http://facebook.github.io/react/index.html">React</a> project, you're likely using a fair amount of AJAX to take advantage of what React can do for you.   These notes don't discuss tying React into a Rails project -- there are several places to read about that -- instead, these notes assume you're using <a href="https://github.com/reactjs/react-rails">react-rails</a> to have your project automatically process React's JSX files in the asset pipeline.</p>

<p>There are several answers on Stack Overflow about scripting for flash messaging in general Javascript; we can adapt this approach to take advantage of React (for instance, see <a href="http://stackoverflow.com/questions/366311/how-do-you-handle-rails-flash-with-ajax-requests">here</a> and <a href="http://stackoverflow.com/questions/21032465/rails-doesnt-display-flash-messages-after-ajax-call">here</a>)</p>

<p>The value of React in this case is that it will automatically update the display when it's data state is updated, so really all that needs to be done is to pipe the data from the server to the client and let React do what it does.  The main details are pretty
straightforward:
<ul>
<li>Transmit flash data from server when there's an update,</li>
<li>Receive flash data on client and amend React component state data, and</li>
<li>React component for displaying content.</li>
<li>Hooking it all together.</li>
</ul>
</p>

<h3>
<a id="transmit" class="anchor" href="#transmit" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transmit</h3>
<p>The StackOverflow notes pretty well spell this out, but here's my implementation.  One advantage of this approach is that it just uses the basic Ruby store of the flash data to keep processing to a minimum.</p>

<p>Natively, flash messages are kept as an array of arrays.   Each child array of the main array is just two elements: the flash message type (`success`, `error`, etc.) and the supplied message text.  Since arrays don't transmit well without some notation to parse, it's just converted to JSON.</p>

<p><em>(app/controllers/application_controller.rb)</em>
<pre><code>class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  after_filter :flash_to_http_header

private
  def flash_to_http_header
    return unless request.xhr?
    return if flash.empty?
    response.headers['X-FlashMessages'] = flash.to_hash.to_json
    flash.discard  # don't want the flash to appear when you reload page
  end
end
</code></pre>
</p>

<h3>
<a id="receiving" class="anchor" href="#receiving" aria-hidden="true"><span class="octicon octicon-link"></span></a>Receiving</h3>

<p>This part assumes that you'll put all the flash related handling into a single `.js.jsx`.  You don't have to of course, but it would keep related functionality together. If you do it the same way I did, then the below function would go in that file.</p>

<p><em>(app/assets/javascripts/react/flash_messages.js.jsx)</em>
<pre><code>function handleFlashMessageHeader(node, xhr) {
  var _message_array = new Array();
  var _raw_messages = xhr.getResponseHeader("X-FlashMessages")
  if (_raw_messages) {
    var _json_messages = JSON.parse(_raw_messages);
    count = 0
    for (var key in _json_messages) {
      _message_array[count] = new Array();
      _message_array[count][0] = key;
      _message_array[count][1] = _json_messages[key];
      count += 1;
    }
  }
  node.messages(_message_array);
}
</code></pre>
</p>

<p>Note that the main processing here is just to convert back to an array of arrays.  That way the React component can simply direct invocations from a RoR view the same as in AJAX processing.</p>

<p>The <code>node</code> parameter is just the DOM node of the rendered React component which we'll outline next.</p>


<h3>
<a id="component" class="anchor" href="#component" aria-hidden="true"><span class="octicon octicon-link"></span></a>Component</h3>

<p>The component isn't too complicated, but a couple of things are worth a closer look.
First, the props are immediately converted to state for use in the <code>render</code> function.  This normally is an anti-pattern in React, but it allows the state to be updated dynamically in response to AJAX calls.
The <code>messages</code> function is needed for non-React JS calls to update the state with new information (which is why props don't work well).
Finally, the <code>render</code> function expects an array of 2-element arrays to produce each flash message -- again, this allows the component to be used directly from a Rails view without preprocessing the data just like in the non-React approach at the start of this post.
</p>

<p>You'll also see the use of <code>flash_class</code> in the <code>render</code> and the corresponding local member function.  Again, this is just for Bootstrap styling.
If your flash messages are going to be handled exclusively client-side, then the server-side <code>application_helper.rb</code> need not handle it (and so can DRY out the code a bit).
</p>

<p><em>(app/assets/javascripts/react/flash_messages.js.jsx)</em>
<pre><code>/** @jsx React.DOM */

var FlashMessages = React.createClass({
  getInitialState: function() {
    return {messages: this.props.messages};
  },

  messages: function (messageArray) {
    this.replaceState({messages: messageArray});
  },

  render: function() {
    return (
      <div className='flash_messages_component'>
        {this.state.messages.map(function(message, index) {
          _level = message[0];
          _text  = message[1];
          return (
            <div key={index} className={this._flash_class(_level)}>
              {_text}
            </div>
          );
        }.bind(this))}
      </div>
    )
  },

  _flash_class: function(level) {
    var _result = 'alert alert-error';
    if (level === 'notice') {
      _result = 'alert alert-info';
    } else if (level === 'success') {
      _result = 'alert alert-success';
    } else if (level === 'error') {
      _result = 'alert alert-error';
    } else if (level === 'alert') {
      _result = 'alert alert-error';
    }
    return _result;
  }

});
</code></pre>
</p>

<h3>
<a id="rendering" class="anchor" href="#rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rendering</h3>
<p>Here&apos;s a quick invocation for when the page is loaded.  Notice that <code>flashDiv</code> below came from a direct <code>React.render</code> (previously <code>React.renderComponent</code>) call. Note too that it uses a div id&apos;ed by <code>#flash_messages</code>. </p>

<p>By simply calling the receiver function whenever an AJAX call completes, the React component's state is updated triggering an immediate re-render of the incoming flash messages.  Obviously, other JQuery events could be used to trigger a flash check, but for AJAX calls, this is
the most obvious.</p>

<p><em>(app/assets/javascripts/react/flash_messages.js.jsx)</em>
<pre><code>$(document).ready(function() {
  var flashDiv = React.render(<FlashMessages/>, $('#flash_messages')[0]);

  $(document).ajaxComplete(function(event, xhr, settings) {
    handleFlashMessageHeader(flashDiv, xhr);
  });
});
</code></pre>
</p>

<p>Beware that in this implementation the <code>flashDiv</code> variable from the call to <code>React.render</code> and the earlier code with the <code>function handleFlashMessageHeader</code> are in global namespace on the JS side which may not be appropriate for some production applications.</p>

<p>Finally, we change the view of the application layout (see above) to just mark where the flash messages should be placed via the <code>#flash_messages</code> place holder from

<p><em>(partial of app/views/layouts/application.html.haml)</em>
<pre><code>%div#flash_messages
  - flash.each do |level, message|
    %div{class: "#{flash_class(level)}"}&lt;
      = message
</code></pre>
</p>

<p>to just</p>
<pre><code>%div#flash_messages
</code></pre>

<h3>
<a id="non-ajax-rendering" class="anchor" href="#non-ajax-rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-AJAX Rendering</h3>
<p>If, however, AJAX isn&apos;t that important, the React component can be used directly from the view:

<pre><code>= react-component('FlashMessages', flash, 'div#flash_messages')
</code></pre>
</p>

<p>or even just</p>

<pre><code>= react-component('FlashMessages', flash, :div)
</code></pre>


<p>Probably not a lot of value using React though if AJAX isn&apos;t involved, but it does allow more DRY code if some pages&apos; functionality depends on AJAX and other don&apos;t.</p>

<h3>
<a id="Wrapup" class="anchor" href="#wrapup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wrapup</h3>

Here is the complete JSX file that handles the client-side processing with ReactJS:
<p><em>(app/assets/javascripts/react/flash_messages.js.jsx)</em>
<pre><code>/** @jsx React.DOM */

var FlashMessages = React.createClass({
  getInitialState: function() {
    return {messages: this.props.messages};
  },

  messages: function (messageArray) {
    this.setState({messages: messageArray});
  },

  render: function() {
    return (
      <div className='flash_messages_component'>
        {this.state.messages.map(function(message, index) {
          _level = message[0];
          _text  = message[1];
          return (
            <div key={index} className={this._flash_class(_level)}>
              {_text}
            </div>
          );
        }.bind(this))}
      </div>
    )
  },

  _flash_class: function(level) {
    var _result = 'alert alert-error';
    if (level === 'notice') {
      _result = 'alert alert-info';
    } else if (level === 'success') {
      _result = 'alert alert-success';
    } else if (level === 'error') {
      _result = 'alert alert-error';
    } else if (level === 'alert') {
      _result = 'alert alert-error';
    }
    return _result;
  }

});

function handleFlashMessageHeader(node, xhr) {
  var _message_array = new Array();
  var _raw_messages = xhr.getResponseHeader("X-FlashMessages")
  if (_raw_messages) {
    var _json_messages = JSON.parse(_raw_messages);
    count = 0
    for (var key in _json_messages) {
      _message_array[count] = new Array();
      _message_array[count][0] = key;
      _message_array[count][1] = _json_messages[key];
      count += 1;
    }
  }
  node.messages(_message_array);
}

$(document).ready(function() {
  var dummy = new Array();
  var flashDiv = React.render(<FlashMessages messages={dummy} />, $('#flash_messages')[0]);

  $(document).ajaxComplete(function(event, xhr, settings) {
    handleFlashMessageHeader(flashDiv, xhr);
  });
});
</code></pre>
</p>

      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
